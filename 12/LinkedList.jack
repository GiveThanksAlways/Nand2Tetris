


class LinkedList {
	field int length; // length of the list
	field int pointer; // the pointer of the block (where it actually is)
	field LinkedList next; // point to the next list

	static int heapIndex;

	// construct a new list
	constructor LinkedList new(int inputlength,int thePointer, LinkedList node){
		let length = inputlength;
		let pointer = thePointer;
		let next = node;
		return this;

	}

	// setter for length
	method void setLength(int input){
		let length = input;
		return;
	}
	// get length
	method int getlength() { return length;}

	// return the current list Pointer
	method int getpointer(){ return pointer;}

	// return next
	method LinkedList getnext(){ return next; }

	// Delete the abstract data types from the memory heap
	method void dispose() {
		if(~(next = null)) {
			do next.dispose();
		}

		do Memory.deAlloc(this);
		return;
	}


	method int transverseAlloc(int size){
		// walk through the linked list and check for any collisions
		// using recursion

		if(~(next = null)) {
			// first fit
			var int heapIndex;
			let heapIndex = heapIndex + length; // heapIndex adding as you walk along to keep track of where you are

			if (length > size){
				// cut list into two separate lists
				let length = length - size -1; // minus one for the length of the next block

				/** create new block with null because he is off in space chilling by himself until he gets
				*		deAlloc. When that happens you can just add him back to the freeList
				*/
				do LinkedList.new(size + 1,(heapIndex - size), null);

				return (heapIndex - size); // returns the int pointer of where in the heap the new block is
			}

      // recursion to call function on next node
			do next.transverseAlloc(size);
		}

		/** if you get to this code, that means you didn't find any blocks of that size
		* 	so now we will do defragmentation.
		*  	For defragmentation, search through the freeList (which is a linked list)
		*		and if two blocks are next to eachother combine them. (if the pointer plus length equals the next pointer
		*   then they are next to eachother in the code)
		*/
		do defragmentation();
		return -1; // failure
	}

	method void defragmentation(int lastPointer) {
		if(~(next = null)){
		// check if this pointer + length equals the next pointer, if so, they are next to eachother
			if((pointer + length) = next.getPointer()){
				// hit, they are next to eachother. We need to combine them now. Make this next list point to the next list and combine the length of the two and then we are done.
				let length = length + next.getlength(); // combine the length with the next guy
				let next 	 = next.getnext(); // sets the current list next to the next of the second block

			}
			do defragmentation(); // recursion call
		}
		return;
	}


} // end of class
